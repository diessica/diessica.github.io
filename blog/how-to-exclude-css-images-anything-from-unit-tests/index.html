<!doctype html><html class="scroll-smooth md:border-[10px] md:border-solid min-h-screen md:border-purple" lang=en><head><meta charset=utf-8><link href="/css/style.css?h=012c5f95ea1463230821" rel=stylesheet><meta content="width=device-width,initial-scale=1" name=viewport><title>How to Exclude CSS, Images, Anything from Unit Tests | Diéssica Gurskas</title><body class="text-gray-700 font-body antialiased"><div class="bg-blog px-3 md:px-10 min-h-[calc(100vh-16px)] lg:min-h-[calc(100vh-20px)]"><div class="py-12 mb-4 text-center space-x-8 text-md md:text-lg relative z-20"><a class="no-underline font-extrabold hover:border-green hover:border-b-2" href=/>diessi.ca</a><a class="no-underline hover:border-green hover:border-b-2 border-green border-b-2" href=/blog/>Blog</a><a class="no-underline hover:border-green hover:border-b-2" href=/misc/>Misc</a></div><article class="container mx-auto w-full xl:w-1/2 pb-8"><header class="xl:-mx-56 text-center mb-8 md:mb-12"><div class="uppercase tracking-widest opacity-60 mb-4 text-xs">November 19, 2016</div><h1 class="font-extrabold font-display text-3xl md:text-5xl xl:text-6xl text-slate-900">How to Exclude CSS, Images, Anything from Unit Tests</h1></header><div class="prose prose-sm md:prose 2xl:prose-lg prose-hr:text-red prose-hr:w-48 prose-hr:h-0.5 prose-hr:mx-auto prose-hr:my-4 prose-hr:bg-black prose-hr:opacity-20 prose-hr:border-0 prose-hr:rounded prose-hr:md:my-10 prose-pre:rounded-none prose-blockquote:border-0 prose-blockquote:text-center prose-blockquote:text-xl prose-blockquote:text-current tracking-tight mx-auto prose-headings:text-slate-800 prose-headings:w-max prose-headings:font-display prose-headings:font-extrabold"><div class=summary><p>Your app needs all those <code>require</code>, but your unit tests may not.</div><p>When developing web applications, we deal with assets that our JavaScript tests don’t have to be aware of.<p>If using Webpack, which enables different imports in your JavaScript files, you’ve configured <a href=https://webpack.github.io/docs/loaders.html>loaders</a> that your test runner probably know nothing about. Therefore, that SVG image in your React component and the <code>import</code>ed CSS will both be parsed like JavaScript in your tests. A lot of confusing errors will be thrown, of course.<p>So let’s learn to exclude anything your unit tests, from styles (CSS, Sass), images (PNG, SVG), to other specific imports (like <a href=https://diessi.ca/blog/svg-images-as-react-components-with-webpack/>SVG images as React components</a>).<h2 id=hook-your-require-calls>Hook your <code>require()</code> calls</h2><p>By intercepting <code>require()</code> calls, you can make your testing framework ignore <strong>what you want</strong> to be ignored <strong>the way you want</strong> it to be ignored.<p>It’s also useful in isomorphic setups.<h3 id=return-an-empty-module>Return an empty module</h3><p>It all comes to returning an empty module for unwanted imports. It looks like this:<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#66d9ef;font-style:italic>module</span><span style=color:#ff79c6>.</span><span style=color:#66d9ef;font-style:italic>exports </span><span style=color:#ff79c6>= </span><span style=color:#f1fa8c>""</span><span>;
</span></code></pre><h3 id=jest>Jest</h3><p>For Jest, configure <a href=https://facebook.github.io/jest/docs/configuration.html#modulenamemapper-object-string-string>moduleNameMapper</a> to return the empty module for specific extensions. Example:<pre class=language-json data-lang=json style=color:#f8f8f2;background-color:#282a36><code class=language-json data-lang=json><span style=color:#eee>"</span><span style=color:#f1fa8c>jest</span><span style=color:#eee>"</span><span>: {
</span><span>  </span><span style=color:#eee>"</span><span style=color:#f1fa8c>moduleNameMapper</span><span style=color:#eee>"</span><span>: {
</span><span>    </span><span style=color:#eee>"</span><span style=color:#ff79c6>\\</span><span style=color:#f1fa8c>.(css|jpg|png)$</span><span style=color:#eee>"</span><span>: </span><span style=color:#eee>"</span><span style=color:#f1fa8c>&LTrootDir>/empty-module.js</span><span style=color:#eee>"
</span><span>  }
</span><span>}
</span></code></pre><h3 id=other-testing-frameworks>Other testing frameworks</h3><p><a href=https://www.npmjs.com/package/require-hacker>require-hacker</a> is an option for hooking <code>require()</code> calls.<p class=note><p>You can also use built-in compilers (like moduleNameMapper in Jest or <a href=https://mochajs.org/#compilers>Mocha compilers</a>), or even only import <a href=https://github.com/bkonkle/ignore-styles>ignore-styles</a> into your testing framework (which is preconfigured).<p>I’ll stick to require-hacker and custom configuration because there’s more flexibility.<p>Get it from npm:<pre class=language-sh data-lang=sh style=color:#f8f8f2;background-color:#282a36><code class=language-sh data-lang=sh><span style=color:#50fa7b>npm</span><span> install require-hacker</span><span style=color:#ffb86c;font-style:italic> --save-dev
</span></code></pre><h4 id=configure>Configure</h4><p>Create a JavaScript file and set custom handlers for specific extensions using require-hacker’s <a href=https://github.com/halt-hammerzeit/require-hacker#hookfile_extension-resolve>hook()</a> method.<p>Assuming you want to ignore CSS and PNG files, always return an empty module for them:<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#ff79c6>import </span><span style=color:#fff>requireHacker </span><span style=color:#ff79c6>from </span><span style=color:#f1fa8c>"require-hacker"</span><span>;
</span><span style=color:#fff>requireHacker</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>hook</span><span>(</span><span style=color:#f1fa8c>"png"</span><span>, () </span><span style=color:#8be9fd;font-style:italic>=> </span><span style=color:#f1fa8c>'module.exports = ""'</span><span>);
</span><span style=color:#fff>requireHacker</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>hook</span><span>(</span><span style=color:#f1fa8c>"css"</span><span>, () </span><span style=color:#8be9fd;font-style:italic>=> </span><span style=color:#f1fa8c>'module.exports = ""'</span><span>);
</span></code></pre><p class=note><p>Because you’re smart, you’ll store all extensions in a variable and <code>forEach</code> them, so there’s no need to repeat yourself. <a href=https://gist.github.com/diessica/e6a6ea601d2b19cdcc6881197b6b5c8d>Example</a>.<h4 id=import-into-your-test-runner>Import into your test runner</h4><p>Let your favourite testing framework know about the <code>require</code> hacking! Some examples, assuming a <code>ignore-utils.js</code> file:<h5 id=mocha>Mocha</h5><p>Add to your <a href=https://mochajs.org/#mochaopts>mocha.opts</a>, or use the <code>--require</code> flag:<pre class=language-sh data-lang=sh style=color:#f8f8f2;background-color:#282a36><code class=language-sh data-lang=sh><span style=color:#50fa7b>mocha</span><span style=color:#ffb86c;font-style:italic> --require</span><span> ./ignore-utils
</span></code></pre><h5 id=ava>ava</h5><p>Add to your <code>package.json</code>:<pre class=language-json data-lang=json style=color:#f8f8f2;background-color:#282a36><code class=language-json data-lang=json><span style=color:#eee>"</span><span style=color:#f1fa8c>ava</span><span style=color:#eee>"</span><span>: {
</span><span>  </span><span style=color:#eee>"</span><span style=color:#f1fa8c>require</span><span style=color:#eee>"</span><span>: [
</span><span>    </span><span style=color:#eee>"</span><span style=color:#f1fa8c>./ignore-utils</span><span style=color:#eee>"
</span><span>  ]
</span><span>}
</span></code></pre><p>Now some files will be treated like shit in your JavaScript tests – which is AWESOME!<h2 id=bonus-react-null-component>Bonus: React null component</h2><p>You don’t need to load that boring SVG icon of a house to test that critical feature in a React component, right?<p><em>Right.</em> In case you’re using <a href=https://github.com/sairion/svg-inline-loader>svg-inline-loader</a>, which transform your SVG files into React components, you cannot just return an empty module because your test case would be actually expecting a React component. Things will break. Annoying errors will be shown.<p>So, instead of returning an empty module for SVG files, return an empty React component. Let’s set a custom handler for that!<h3 id=configure-1>Configure</h3><p class=note><p>This example uses require-hacker. For Jest, export a React null component and set it in <code>moduleNameMapper</code>.<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#ff79c6>import </span><span style=color:#fff>requireHacker </span><span style=color:#ff79c6>from </span><span style=color:#f1fa8c>"require-hacker"</span><span>;
</span><span>
</span><span style=color:#8be9fd;font-style:italic>const </span><span style=color:#fff>reactNullComponent </span><span style=color:#ff79c6>= </span><span style=color:#f1fa8c>`
</span><span style=color:#f1fa8c>  require('react').createClass({
</span><span style=color:#f1fa8c>    render() {
</span><span style=color:#f1fa8c>      return null;
</span><span style=color:#f1fa8c>    }
</span><span style=color:#f1fa8c>  })
</span><span style=color:#f1fa8c>`</span><span>;
</span><span style=color:#fff>requireHacker</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>hook</span><span>(</span><span style=color:#f1fa8c>"svg"</span><span>, () </span><span style=color:#8be9fd;font-style:italic>=> </span><span style=color:#f1fa8c>`module.exports = ${</span><span style=color:#fff>reactNullComponent</span><span style=color:#f1fa8c>}`</span><span>);
</span></code></pre><h2 id=conclusion>Conclusion</h2><p>I’ve spent a lot of time figuring out how to make everything work, because:<ol><li>At the beginning, it was quite confusing to get what was clearly going on.<li>There’s a ton of options out there (Webpack null loaders; <a href=https://github.com/bkonkle/ignore-styles>ignore-styles</a>, which also provide custom handlers; <a href=https://github.com/morlay/babel-plugin-transform-require-ignore>babel-plugin-transform-require-ignore</a>…).<li>I didn’t want to handle all the ignored extensions the same say.</ol><p>Yeah… Sometimes our JavaScript unit tests just know too much.</div></article></div></body><script src=/footnotes.js></script>