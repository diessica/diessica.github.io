<!doctype html><html class="scroll-smooth md:border-[10px] md:border-solid min-h-screen md:border-purple" lang=en><head><meta charset=utf-8><link href="/css/style.css?h=012c5f95ea1463230821" rel=stylesheet><meta content="width=device-width,initial-scale=1" name=viewport><title>O Til no JavaScript | Diéssica Gurskas</title><body class="text-gray-700 font-body antialiased"><div class="bg-blog px-3 md:px-10 min-h-[calc(100vh-16px)] lg:min-h-[calc(100vh-20px)]"><div class="py-12 mb-4 text-center space-x-8 text-md md:text-lg relative z-20"><a class="no-underline font-extrabold hover:border-green hover:border-b-2" href=/>diessi.ca</a><a class="no-underline hover:border-green hover:border-b-2 border-green border-b-2" href=/blog/>Blog</a><a class="no-underline hover:border-green hover:border-b-2" href=/misc/>Misc</a></div><article class="container mx-auto w-full xl:w-1/2 pb-8"><header class="xl:-mx-56 text-center mb-8 md:mb-12"><div class="uppercase tracking-widest opacity-60 mb-4 text-xs">October 31, 2015</div><h1 class="font-extrabold font-display text-3xl md:text-5xl xl:text-6xl text-slate-900">O Til no JavaScript</h1></header><div class="prose prose-sm md:prose 2xl:prose-lg prose-hr:text-red prose-hr:w-48 prose-hr:h-0.5 prose-hr:mx-auto prose-hr:my-4 prose-hr:bg-black prose-hr:opacity-20 prose-hr:border-0 prose-hr:rounded prose-hr:md:my-10 prose-pre:rounded-none prose-blockquote:border-0 prose-blockquote:text-center prose-blockquote:text-xl prose-blockquote:text-current tracking-tight mx-auto prose-headings:text-slate-800 prose-headings:w-max prose-headings:font-display prose-headings:font-extrabold"><p class=summary><p>Incompreendido, o operador til (<code>~</code>) é um mistério que ninguém discute. Primeiro, pois é um operador bitwise, e, segundo, pois seus casos de uso são bastante misteriosos…<h2 id=voce-consegue-dizer>Você consegue dizer…</h2><p>em <strong>valor</strong> e <strong>tipo de dado</strong>, o que será impresso no console nas situações abaixo?<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~~</span><span style=color:#f1fa8c>"1"</span><span>);
</span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~</span><span style=color:#bd93f9>8.2</span><span>);
</span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~</span><span style=color:#bd93f9>false</span><span>);
</span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~~</span><span style=color:#f1fa8c>"5.9"</span><span>);
</span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~~</span><span>{});
</span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~~-</span><span style=color:#bd93f9>5.5</span><span>);
</span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~</span><span style=color:#f1fa8c>"Tudo bem?"</span><span>);
</span></code></pre><p>Não sabe? <em>Well…</em><h2 id=o-operador-til>O operador til</h2><p>Ou melhor, o operador <em>bitwise NOT</em>.<p>É importante falar isso pois é importante entender o que <em>bitwise</em> significa. Operadores bitwise são especiais em JavaScript: eles tratam todos seus operandos como uma sequência de 32 bits (0 e 1) – ou seja, trabalham com <strong>representações binárias</strong> (não decimais, como de praxe) de nossos operandos, e nos entregam valores númericos como se nada tivesse acontecido.<p>O <em>NOT</em> significa que todos os bits do operando serão invertidos (0 vira 1, 1 vira 0). Parece inútil quando não estamos trabalhando com números binários, mas as aplicações criativas tornam o operador mais interessante.<h3 id=regras-do>Regras do <code>~</code></h3><ol><li>Quando a expressão é <code>null</code> ou <code>undefined</code>… 0.<li>Objetos são convertidos para strings.<li>Strings são convertidas para números, se possível. Quando não é possível… 0.<li>Valores booleanos são tratados como números (0 para <code>false</code>, 1 para <code>true</code>).<li><em>Floating-points</em> são convertidos excluindo a parte fracionada.<li>Todo número inteiro <em>n</em> é convertido para -(n + 1).</ol><p>As duas últimas regras são as mais importantes, pois elas implicam nas principais aplicações do operador. Já temos a resposta de alguns:<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~</span><span style=color:#bd93f9>8.2</span><span>); </span><span style=color:#6272a4>// => -9
</span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~</span><span style=color:#bd93f9>false</span><span>); </span><span style=color:#6272a4>// => -1
</span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~</span><span style=color:#f1fa8c>"Tudo bem?"</span><span>); </span><span style=color:#6272a4>// => -1
</span></code></pre><p class=note><p>Os números foram convertidos de acordo com a fórmula -(n + 1). -9 é resultado de - 8 - 1, por exemplo.<h3 id=dupla-negacao>Dupla negação</h3><p>Podemos usar dois operadores til (<em>double bitwise NOT</em>). Aqui, basta entender o trabalho do outro til: reinverter os bits.<p>Considerando <code>~n</code>, como anteriormente, temos -(n + 1) = <strong>- n - 1</strong>. Considerando <code>~~n</code>, temos -[-(n + 1)] = <strong>n + 1</strong>.<p>Perceba que as equações, quando somadas, se anulam. Pois essa é a grande sacada de usar dois operadores til! Temos, então:<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~~</span><span style=color:#f1fa8c>"1"</span><span>); </span><span style=color:#6272a4>// => 1
</span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~~</span><span style=color:#f1fa8c>"5.9"</span><span>); </span><span style=color:#6272a4>// => 5
</span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~~</span><span>{}); </span><span style=color:#6272a4>// => 0
</span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#ff79c6>~~-</span><span style=color:#bd93f9>5.5</span><span>); </span><span style=color:#6272a4>// => -5
</span></code></pre><h2 id=aplicacoes>Aplicações</h2><h3 id=truncar-numeros>Truncar números</h3><p>Pelo fato do operador converter removendo a parte fracionada, utilizá-lo para truncar números de forma fácil é a aplicação mais comum:<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#8be9fd;font-style:italic>let </span><span style=color:#fff>data </span><span style=color:#ff79c6>= </span><span style=color:#bd93f9>7.8926152</span><span>;
</span><span style=color:#8be9fd;font-style:italic>const </span><span style=color:#fff>integer </span><span style=color:#ff79c6>= ~~</span><span style=color:#fff>data</span><span>;
</span><span>
</span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#fff>integer</span><span>); </span><span style=color:#6272a4>// => 7
</span></code></pre><p class=note><p>Embora o <code>~~</code> tenha sido, por muito tempo, usado no lugar de <code>Math.floor()</code>, o método mais parecido com ele que temos em JavaScript hoje é o <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc><code>Math.trunc()</code></a> do ES2015.<h3 id=converter-string-para-numero>Converter string para número</h3><p>Uma aplicação simples que se baseia em uma das regras de funcionamento do til: converter strings para números sempre que possível; afinal, é com números que o operador trabalha.<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#8be9fd;font-style:italic>let </span><span style=color:#fff>data </span><span style=color:#ff79c6>= </span><span style=color:#f1fa8c>"2"</span><span>;
</span><span style=color:#8be9fd;font-style:italic>const </span><span style=color:#fff>dataAsNumber </span><span style=color:#ff79c6>= ~~</span><span style=color:#fff>data</span><span>;
</span><span>
</span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#fff>dataAsNumber</span><span>); </span><span style=color:#6272a4>// => 2
</span></code></pre><h3 id=verificar-a-existencia-de-um-item-no-array>Verificar a existência de um item no array</h3><pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#8be9fd;font-style:italic>let </span><span style=color:#fff>women </span><span style=color:#ff79c6>= </span><span>[</span><span style=color:#f1fa8c>"Ada Lovelace"</span><span>, </span><span style=color:#f1fa8c>"Joan of Arc"</span><span>, </span><span style=color:#f1fa8c>"Marie Curie"</span><span>];
</span><span>
</span><span style=color:#ff79c6>if </span><span>(</span><span style=color:#ff79c6>~</span><span style=color:#fff>women</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>indexOf</span><span>(</span><span style=color:#f1fa8c>"Ada Lovelace"</span><span>)) {
</span><span>  </span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#f1fa8c>"Ada Lovelace was such an important woman!"</span><span>);
</span><span>}
</span></code></pre><p>É difícil de compreender humanamente que o <code>if</code> está verificando se Ada Lovelace está incluída no array <code>women</code>, mas é exatamente isso que está acontecendo. Você entendeu a razão pela qual isso funciona?<p class=note><p>Poderíamos verificar sem o <code>~</code>, mas não funcionaria em casos em que o item do array é o primeiro (índice zero, e 0 retorna <code>false</code> como booleano). O operador til viabiliza essa verificação, em razão da conversão de um número inteiro <em>n</em> para -(n + 1).<p>O equivalente humano, utilizando <a href=https://lodash.com/>Lodash</a> (<code>_</code>), seria:<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#8be9fd;font-style:italic>let </span><span style=color:#fff>women </span><span style=color:#ff79c6>= </span><span>[</span><span style=color:#f1fa8c>"Ada Lovelace"</span><span>, </span><span style=color:#f1fa8c>"Joan of Arc"</span><span>, </span><span style=color:#f1fa8c>"Marie Curie"</span><span>];
</span><span>
</span><span style=color:#ff79c6>if </span><span>(</span><span style=color:#50fa7b>_</span><span>(</span><span style=color:#fff>women</span><span>)</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>contains</span><span>(</span><span style=color:#f1fa8c>"Ada Lovelace"</span><span>)) {
</span><span>  </span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#f1fa8c>"Ada Lovelace was such an important woman!"</span><span>);
</span><span>}
</span></code></pre><h2 id=performance>Performance</h2><p>Usar <code>~~</code> em vez de <code>Math.floor</code> ou <code>Math.trunc</code> é geralmente mais rápido. Dependendo da <em>JavaScript engine</em> do navegador e do caso de uso, no entanto, pode não fazer muita diferença e até ser mais lento. Veja o <a href=http://jsperf.com/tilde-vs-floor>teste no JSPerf</a>.<p>De qualquer forma, a péssima performance de quem lê um código com o desumano <code>~</code> pode não valer o ganho de performance – que é ignorável de tão mínimo – em uma aplicação.<h2 id=consideracoes>Considerações</h2><p>No geral, operadores bitwise, principalmente <code>~</code>, <code>|</code> e <code>&</code>, possuem aplicações interessantes e bastante criativas.<p>Quanto ao <code>~~</code>, não acredito que chegará a se popularizar como aconteceu com o <code>!!</code>, que converte para um valor booleano. Em anos, a prática com til nunca se tornou realmente popular, talvez pelo fato de ser um operador bitwise – e, portanto, pouco compreendido – e ter casos de uso bastante excêntricos.<p>Ficam à título de curiosidade suas aplicações bastante criativas. ;-)</div></article></div></body><script src=/footnotes.js></script>