<!doctype html><html class="scroll-smooth md:border-[10px] md:border-solid min-h-screen md:border-purple" lang=en><head><meta charset=utf-8><link href="/css/style.css?h=012c5f95ea1463230821" rel=stylesheet><meta content="width=device-width,initial-scale=1" name=viewport><title>Encadeamento de Métodos em JavaScript | Diéssica Gurskas</title><body class="text-gray-700 font-body antialiased"><div class="bg-blog px-3 md:px-10 min-h-[calc(100vh-16px)] lg:min-h-[calc(100vh-20px)]"><div class="py-12 mb-4 text-center space-x-8 text-md md:text-lg relative z-20"><a class="no-underline font-extrabold hover:border-green hover:border-b-2" href=/>diessi.ca</a><a class="no-underline hover:border-green hover:border-b-2 border-green border-b-2" href=/blog/>Blog</a><a class="no-underline hover:border-green hover:border-b-2" href=/misc/>Misc</a></div><article class="container mx-auto w-full xl:w-1/2 pb-8"><header class="xl:-mx-56 text-center mb-8 md:mb-12"><div class="uppercase tracking-widest opacity-60 mb-4 text-xs">August 06, 2016</div><h1 class="font-extrabold font-display text-3xl md:text-5xl xl:text-6xl text-slate-900">Encadeamento de Métodos em JavaScript</h1></header><div class="prose prose-sm md:prose 2xl:prose-lg prose-hr:text-red prose-hr:w-48 prose-hr:h-0.5 prose-hr:mx-auto prose-hr:my-4 prose-hr:bg-black prose-hr:opacity-20 prose-hr:border-0 prose-hr:rounded prose-hr:md:my-10 prose-pre:rounded-none prose-blockquote:border-0 prose-blockquote:text-center prose-blockquote:text-xl prose-blockquote:text-current tracking-tight mx-auto prose-headings:text-slate-800 prose-headings:w-max prose-headings:font-display prose-headings:font-extrabold"><p>Popular em diversas bibliotecas JavaScript, o encadeamento de métodos (<em>“method chaining”</em>) é uma técnica usada para invocar diversos métodos em um mesmo objeto.<p>Com o objetivo de <strong>melhorar a legibilidade do código</strong>, a técnica é vastamente utilizada na API da jQuery, o que certamente influenciou na popularidade da biblioteca.<p>Se você já utilizou jQuery, o estilo do código abaixo pode ser familiar:<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#50fa7b>$</span><span>(</span><span style=color:#f1fa8c>"#my-element"</span><span>)
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>css</span><span>(</span><span style=color:#f1fa8c>"background"</span><span>, </span><span style=color:#f1fa8c>"purple"</span><span>)
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>height</span><span>(</span><span style=color:#bd93f9>100</span><span>)
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>animate</span><span>({ height: </span><span style=color:#bd93f9>250 </span><span>})
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>find</span><span>(</span><span style=color:#f1fa8c>"input"</span><span>)
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>fadeIn</span><span>(</span><span style=color:#bd93f9>200</span><span>)
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>val</span><span>(</span><span style=color:#f1fa8c>""</span><span>)
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>end</span><span>();
</span></code></pre><p class=note><p>No exemplo acima, uma única declaração faz várias coisas. No entanto, uma boa prática com <em>method chaining</em> é <strong>fazer somente uma ação por declaração</strong>. ;-)<p>Perceba que vários métodos são invocados no objeto <code>$('#my-element')</code>, sem a necessidade de repetí-lo. Já sem <em>Method Chaining</em>, é necessário fazer a referência diversas vezes:<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#8be9fd;font-style:italic>const </span><span style=color:#fff>myElement </span><span style=color:#ff79c6>= </span><span style=color:#50fa7b>$</span><span>(</span><span style=color:#f1fa8c>"#my-element"</span><span>);
</span><span style=color:#fff>myElement</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>css</span><span>(</span><span style=color:#f1fa8c>"background"</span><span>, </span><span style=color:#f1fa8c>"purple"</span><span>);
</span><span style=color:#fff>myElement</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>height</span><span>(</span><span style=color:#bd93f9>100</span><span>);
</span><span style=color:#fff>myElement</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>fadeIn</span><span>(</span><span style=color:#bd93f9>200</span><span>);
</span></code></pre><h2 id=exemplo>Exemplo</h2><p>Vamos criar um contador <code>Counter</code>:<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#ff79c6;font-style:italic>class </span><span>Counter {
</span><span>  </span><span style=color:#8be9fd;font-style:italic>constructor</span><span>() {
</span><span>    </span><span style=color:#bd93f9>this</span><span style=color:#ff79c6>.</span><span>value </span><span style=color:#ff79c6>= </span><span style=color:#bd93f9>0</span><span>;
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#50fa7b>increase</span><span>() {
</span><span>    </span><span style=color:#bd93f9>this</span><span style=color:#ff79c6>.</span><span>value </span><span style=color:#ff79c6>+= </span><span style=color:#bd93f9>1</span><span>;
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#50fa7b>decrease</span><span>() {
</span><span>    </span><span style=color:#bd93f9>this</span><span style=color:#ff79c6>.</span><span>value </span><span style=color:#ff79c6>-= </span><span style=color:#bd93f9>1</span><span>;
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#50fa7b>log</span><span>() {
</span><span>    </span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#bd93f9>this</span><span style=color:#ff79c6>.</span><span>value);
</span><span>  }
</span><span>}
</span></code></pre><p>Agora, vamos instanciar um contador e usar seus métodos:<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#8be9fd;font-style:italic>const </span><span style=color:#fff>counter </span><span style=color:#ff79c6>= new </span><span>Counter();
</span><span style=color:#fff>counter</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>increase</span><span>();
</span><span style=color:#fff>counter</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>log</span><span>(); </span><span style=color:#6272a4>// => 1
</span><span style=color:#fff>counter</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>decrease</span><span>();
</span><span style=color:#fff>counter</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>log</span><span>(); </span><span style=color:#6272a4>// => 0
</span></code></pre><p>Perceba que é necessário fazer várias declarações para interagir com a instância, o que prejudica a legibilidade do código.<p>E se tentarmos usar <em>Method Chaining</em>…<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#ff79c6>new </span><span>Counter()</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>increase</span><span>()</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>log</span><span>();
</span><span style=color:#6272a4>// > TypeError: Cannot read property 'log' of undefined
</span></code></pre><p>Perceba que <code>log()</code> está sendo executado em <code>new Counter().increase()</code>, que, por sua vez, está retornando <code>undefined</code>. Portanto, ainda não é possível interagir com <code>Counter</code> dessa forma.<h2 id=como-encadear-metodos>Como Encadear Métodos</h2><p>Para evitar a repetição do objeto, é necessário que seus métodos retornem o próprio objeto.<p>Veja este exemplo com Promises:<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#50fa7b>getJSON</span><span>(</span><span style=color:#f1fa8c>"users.json"</span><span>)
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>then</span><span>(</span><span style=color:#6be5fd>JSON</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>parse</span><span>)
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>then</span><span>((</span><span style=color:#ffb86c;font-style:italic>response</span><span>) </span><span style=color:#8be9fd;font-style:italic>=> </span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#f1fa8c>"Olha o JSON!"</span><span>, </span><span style=color:#fff>response</span><span>))
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>catch</span><span>((</span><span style=color:#ffb86c;font-style:italic>error</span><span>) </span><span style=color:#8be9fd;font-style:italic>=> </span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#f1fa8c>"Falhou!"</span><span>, </span><span style=color:#fff>error</span><span>));
</span></code></pre><p>Isso só é possível pois os métodos <code>then()</code> and <code>catch()</code> sempre retornam outras promises. Assim, podemos dizer que as Promises são <strong>fluent APIs</strong>, tal como a jQuery.<h3 id=quem-lembra-do-this>Quem Lembra do <code>this</code>?</h3><p>Para os métodos serem encadeados, será necessário retornar o contexto (<code>this</code>) em cada método.<blockquote><p>Em JavaScript, <code>this</code> sempre se refere ao contexto de execução de função.</blockquote><p>No caso de um método, que é uma função de um objeto, refere-se ao próprio objeto.<h4 id=exemplo-com-method-chaining-pattern>Exemplo com <em>Method Chaining Pattern</em></h4><p>Para implementar o encadeamento de métodos na classe <code>Counter</code>, apenas retornamos seu contexto a cada método:<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#ff79c6;font-style:italic>class </span><span>Counter {
</span><span>  </span><span style=color:#8be9fd;font-style:italic>constructor</span><span>() {
</span><span>    </span><span style=color:#bd93f9>this</span><span style=color:#ff79c6>.</span><span>value </span><span style=color:#ff79c6>= </span><span style=color:#bd93f9>0</span><span>;
</span><span>  }
</span><span>  </span><span style=color:#50fa7b>increase</span><span>() {
</span><span>    </span><span style=color:#bd93f9>this</span><span style=color:#ff79c6>.</span><span>value </span><span style=color:#ff79c6>+= </span><span style=color:#bd93f9>1</span><span>;
</span><span>    </span><span style=color:#ff79c6>return </span><span style=color:#bd93f9>this</span><span>; </span><span style=color:#6272a4>// Aqui!
</span><span>  }
</span><span>  </span><span style=color:#50fa7b>decrease</span><span>() {
</span><span>    </span><span style=color:#bd93f9>this</span><span style=color:#ff79c6>.</span><span>value </span><span style=color:#ff79c6>-= </span><span style=color:#bd93f9>1</span><span>;
</span><span>    </span><span style=color:#ff79c6>return </span><span style=color:#bd93f9>this</span><span>; </span><span style=color:#6272a4>// Aqui!
</span><span>  }
</span><span>  </span><span style=color:#50fa7b>log</span><span>() {
</span><span>    </span><span style=color:#66d9ef;font-style:italic>console</span><span style=color:#ff79c6>.</span><span style=color:#8be9fd>log</span><span>(</span><span style=color:#bd93f9>this</span><span style=color:#ff79c6>.</span><span>value);
</span><span>    </span><span style=color:#ff79c6>return </span><span style=color:#bd93f9>this</span><span>; </span><span style=color:#6272a4>// E aqui!
</span><span>  }
</span><span>}
</span></code></pre><p>Agora, ao executar <code>new Counter().increase()</code>, o retorno já não será mais <code>undefined</code>.<p>…E, portanto, é possível fazer <em>method chaining</em>!<pre class=language-js data-lang=js style=color:#f8f8f2;background-color:#282a36><code class=language-js data-lang=js><span style=color:#ff79c6>new </span><span>Counter()
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>increase</span><span>()
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>log</span><span>() </span><span style=color:#6272a4>// => 1
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>decrease</span><span>()
</span><span>  </span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>log</span><span>(); </span><span style=color:#6272a4>// => 0
</span></code></pre><h2 id=conclusao>Conclusão</h2><p>No universo de APIs orientadas a objetos, o encadeamento de métodos é uma técnica incrível se o seu objetivo é tornar o código mais expressivo e fluente.<p>No geral, <em>fluent APIs</em> são sim interessantes de se entender e implementar, e você pode ter certeza disso analisando o primeiro exemplo com jQuery do início deste artigo. É fantástico! Mas é importante entender que <strong>o encadeamento de métodos nem sempre tornará as coisas mais fáceis</strong> (debugar, por exemplo, se torna mais difícil), e, portanto, a maneira aparentemente “mágica” com que elas funcionam não deve ser sempre levada em consideração.</div></article></div></body><script src=/footnotes.js></script>