<!doctype html><html class="scroll-smooth md:border-[10px] md:border-solid min-h-screen md:border-purple" lang=en><head><meta charset=utf-8><link href="/css/style.css?h=012c5f95ea1463230821" rel=stylesheet><meta content="width=device-width,initial-scale=1" name=viewport><title>Working Better with Git for a Clear History | Diéssica Gurskas</title><body class="text-gray-700 font-body antialiased"><div class="bg-blog px-3 md:px-10 min-h-[calc(100vh-16px)] lg:min-h-[calc(100vh-20px)]"><div class="py-12 mb-4 text-center space-x-8 text-md md:text-lg relative z-20"><a class="no-underline font-extrabold hover:border-green hover:border-b-2" href=/>diessi.ca</a><a class="no-underline hover:border-green hover:border-b-2 border-green border-b-2" href=/blog/>Blog</a><a class="no-underline hover:border-green hover:border-b-2" href=/misc/>Misc</a></div><article class="container mx-auto w-full xl:w-1/2 pb-8"><header class="xl:-mx-56 text-center mb-8 md:mb-12"><div class="uppercase tracking-widest opacity-60 mb-4 text-xs">August 04, 2018</div><h1 class="font-extrabold font-display text-3xl md:text-5xl xl:text-6xl text-slate-900">Working Better with Git for a Clear History</h1></header><div class="prose prose-sm md:prose 2xl:prose-lg prose-hr:text-red prose-hr:w-48 prose-hr:h-0.5 prose-hr:mx-auto prose-hr:my-4 prose-hr:bg-black prose-hr:opacity-20 prose-hr:border-0 prose-hr:rounded prose-hr:md:my-10 prose-pre:rounded-none prose-blockquote:border-0 prose-blockquote:text-center prose-blockquote:text-xl prose-blockquote:text-current tracking-tight mx-auto prose-headings:text-slate-800 prose-headings:w-max prose-headings:font-display prose-headings:font-extrabold"><p>Your teammate worked on a few improvements in all forms of the company’s website. At some point you, also a programmer, are asked for a code review.<p>This is the feature branch’s <strong>commit history</strong> you get in the Pull Request:<pre class=language-sh data-lang=sh style=color:#f8f8f2;background-color:#282a36><code class=language-sh data-lang=sh><span style=color:#50fa7b>[290xx26]</span><span> Resolve merge conflicts
</span><span style=color:#50fa7b>[9efxxf2]</span><span> Refactor event listener for form fields
</span><span style=color:#50fa7b>[5d9xx5a]</span><span> Update snapshots
</span><span style=color:#50fa7b>[948xxfa]</span><span> Update dispatch event
</span><span style=color:#50fa7b>[f5xxea1]</span><span> WIP
</span><span style=color:#50fa7b>[f8xxaae]</span><span> Revert change
</span><span style=color:#50fa7b>[49xxf55e]</span><span> Revert changes
</span><span style=color:#50fa7b>[02xxdf1]</span><span> Update snapshots
</span><span style=color:#50fa7b>[21xx329]</span><span> Pass down prop
</span><span style=color:#50fa7b>[28xxa865]</span><span> Fix onChange event and add minimal design  in form
</span><span style=color:#50fa7b>[cfxx37c]</span><span> U[date snapshots
</span><span style=color:#50fa7b>[cfxx36c]</span><span> Update form to handle onChange event for autofill
</span><span style=color:#50fa7b>[242xx25]</span><span> Fix another bug with onChange
</span><span style=color:#50fa7b>[f7xx738]</span><span> Update form component
</span><span style=color:#50fa7b>[09xx868]</span><span> Update snapshots
</span></code></pre><p>It seems like a lot, when actually those improvements are simply 1) fixing a bug with event handling and 2) introducing a minimal style to them. It just that it takes time to visualise that.<p>Indeed, committing often to a branch is a good practice<sup class=footnote-reference><a href=#1>1</a></sup> and commits are supposed to be low-level rather than huge. However, a commit is applicable when you have a meaningful, self-contained batch of work to log to the history – and updating Jest snapshots is not it.<p>How about the following history?<pre class=language-sh data-lang=sh style=color:#f8f8f2;background-color:#282a36><code class=language-sh data-lang=sh><span style=color:#50fa7b>[9efxxf2]</span><span> Refactor event listener for form fields
</span><span style=color:#50fa7b>[cfxx37c]</span><span> Add minimal design in form
</span><span style=color:#50fa7b>[cfxx36c]</span><span> Update form to handle onChange event for autofill
</span></code></pre><p>That history communicates in a clear way <strong>what</strong> in the codebase has been changed in order to get the improvements done. If you want to know <strong>how</strong> it’s changed, it’s just a matter of checking out a particular commit.<h2 id=why-a-clear-history-matters>Why a clear history matters</h2><p>Apart from facilitating code reviews, since reviewers could grasp the context of the changes right at the first glimpse, <strong>a clear Git history is healthy for the project</strong>.<p>When commits started to reflect one’s workflow rather than the work done itself, the history turns into a mess of both meaningful and meaningless logs, hard to navigate through and undo changes (since commits are “checkpoints” of work). It’s highly likely that, as time goes by, developers will stop caring about the source code history as the powerful resource it is.<p>*<em>The final Git history should reflect <em>your work</em> not the way you worked.</em><p>You begin to lose the benefit of source code management with a messy history, which was supposed to reflect how the codebase evolved over time.<h2 id=a-better-relationship-with-git>A better relationship with Git</h2><p>There are very common comprehensible reasons – yet not excuses at all! – for developers to unnecessarily commit. I can think of:<ol><li>“I had to update snapshots/fix unit test/code formatting/a typo in something I introduced.”<li>“I had to merge master.”<li>“I wanted to save my work.”<li>“I don’t necessarily follow a clear flow – I am productive when I work in iterative way and usually do a lot of things at once.”</ol><p>They can all be worked out by developing a better relationship with Git itself. That might take a while at first, but when it’s part of your daily workflow, you barely think about it at all. <em>(I promise!)</em><h3 id=first-let-s-talk-git-rebasing>First, let’s talk Git rebasing</h3><p><a href=https://git-scm.com/docs/git-rebase>Git rebase</a> is a very powerful tool to reorganise your commits. It does a lot, so I won’t get deep into it.<p>The command <code>git rebase</code> has an important tool you should get comfortable with: <strong>interactive rebase</strong>. Let’s say we want to reorganise the latest 3 commits:<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#282a36><code class=language-bash data-lang=bash><span style=color:#50fa7b>git</span><span> rebase</span><span style=color:#ffb86c;font-style:italic> --interactive</span><span> HEAD</span><span style=color:#bd93f9>~</span><span>3
</span></code></pre><p class=note><code>HEAD</code> points to the current branch in your Git repository. You can use @ as an alias as well: <code>@~3</code>, or the commit hash.<p>Interactive rebase will provide you a text interface with the list of the commits (in this case, within the range <code>HEAD~3..HEAD</code>) that are about to be rebased and actions you can apply to them:<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#282a36><code class=language-bash data-lang=bash><span style=color:#50fa7b>pick </span><span style=color:#ff79c6>[</span><span>242xx25</span><span style=color:#ff79c6>]</span><span> Fix another bug with onChange
</span><span style=color:#50fa7b>pick </span><span style=color:#ff79c6>[</span><span>f7xx738</span><span style=color:#ff79c6>]</span><span> Update form component
</span><span style=color:#50fa7b>pick </span><span style=color:#ff79c6>[</span><span>09xx868</span><span style=color:#ff79c6>]</span><span> Update snapshots
</span><span>
</span><span style=color:#6272a4># Rebase 242xx25..09xx868 onto 242xx25
</span><span style=color:#6272a4>#
</span><span style=color:#6272a4># Commands:
</span><span style=color:#6272a4>#  p, pick = use commit
</span><span style=color:#6272a4>#  r, reword = use commit, but edit the commit message
</span><span style=color:#6272a4>#  e, edit = use commit, but stop for amending
</span><span style=color:#6272a4>#  s, squash = use commit, but meld into previous commit
</span><span style=color:#6272a4>#  f, fixup = like "squash", but discard this commit's log message
</span><span style=color:#6272a4>#  x, exec = run command (the rest of the line) using shell
</span><span style=color:#6272a4>#
</span><span style=color:#6272a4># These lines can be re-ordered; they are executed from top to bottom.
</span><span style=color:#6272a4>#
</span><span style=color:#6272a4># If you remove a line here THAT COMMIT WILL BE LOST.
</span><span style=color:#6272a4>#
</span><span style=color:#6272a4># However, if you remove everything, the rebase will be aborted.
</span><span style=color:#6272a4>#
</span><span style=color:#6272a4># Note that empty commits are commented out
</span></code></pre><p class=note><code>pick</code> just means that commit is included. It's the default.<p>Editing that file (either by applying actions to commits or reordering them) and closing it will reapply those commits to the branch. We’ll explore some scenarios where that is useful.<h3 id=rebase-instead-of-merge>Rebase instead of merge</h3><p>The branch that you branched from has been updated (let’s call it <code>master</code>), so you need to fetch latest changes and merge that into yours with <code>git pull</code>. Instead of merging and introducing an ugly new commit for that, you can rebase and pretend that nothing ever happened in the first place.<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#282a36><code class=language-bash data-lang=bash><span style=color:#50fa7b>git</span><span> pull origin master</span><span style=color:#ffb86c;font-style:italic> --rebase
</span></code></pre><p class=note>"Why isn't that the default then?", you might ask. I'd guess they didn't want to make a feature that rewrites history part of the default behaviour.<h3 id=squash-commits-when-you-can>Squash commits when you can</h3><p>You need to fix a typo, update a test, or include anything else that should have actually been part of a commit previously introduced. You can create a new commit and later squash it to the initial one with rebase.<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#282a36><code class=language-bash data-lang=bash><span style=color:#50fa7b>git</span><span> commit</span><span style=color:#ffb86c;font-style:italic> -m </span><span style=color:#f1fa8c>"Update contact form tests"
</span><span style=color:#50fa7b>git</span><span> rebase</span><span style=color:#ffb86c;font-style:italic> -i</span><span> HEAD</span><span style=color:#bd93f9>~</span><span>2 </span><span style=color:#6272a4># act on top of latest 2 commits
</span></code></pre><p>Interactive rebase will show up, and you can mark that “Update contact form tests” as the commit to be squashed into a previous one by changing pick to <code>s</code> (squash).<p>The squashed commit has to come exactly before the commit you want to squash into, so you might have to some reordering.<h4 id=fix-up-and-save-time>Fix up and save time</h4><p>Using the <code>--fixup</code> flag along with the commit hash of the previous commit will <strong>mark a commit as a fix of an existing one</strong>. Then, when you rebase with <code>--autosquash</code>, they will… well, automatically get squashed.<p>Let’s say we have fixed a typo in the commit <code>i2r923</code>:<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#282a36><code class=language-bash data-lang=bash><span style=color:#50fa7b>git</span><span> commit</span><span style=color:#ffb86c;font-style:italic> --fixup</span><span> i2r923
</span><span style=color:#50fa7b>git</span><span> rebase</span><span style=color:#ffb86c;font-style:italic> --autosquash</span><span> 9ef00f2  </span><span style=color:#6272a4># one commit before above
</span></code></pre><p class=note>You can configure Git to use the <code>--autosquash</code> flag by default when rebasing. I do that so you can check <a href=https://github.com/diessica/dotfiles/blob/master/git/config>my dotfiles</a> if you're curious.<p>Quite often, you’ll know how far you’re traveling from the current commit (HEAD). Instead of specifying hashes, you can just use <code>HEAD</code> as a reference to previous commits:<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#282a36><code class=language-bash data-lang=bash><span style=color:#50fa7b>git</span><span> commit</span><span style=color:#ffb86c;font-style:italic> --fixup</span><span> HEAD            </span><span style=color:#6272a4># fix 1 commit before HEAD
</span><span style=color:#50fa7b>git</span><span> rebase</span><span style=color:#ffb86c;font-style:italic> --autosquash -i</span><span> HEAD</span><span style=color:#bd93f9>~</span><span>1  </span><span style=color:#6272a4># squash latest 2 commits
</span></code></pre><h3 id=stash-to-save-your-work-in-progress>Stash to save your work in progress</h3><p>You want to check or change other branch’s files, but don’t want to commit unfinished work either. You can <strong>stash your work in progress</strong> (“WIP”):<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#282a36><code class=language-bash data-lang=bash><span style=color:#50fa7b>git</span><span> stash
</span></code></pre><p>That stores everything from your working directory into stash. It’s so useful in my day-to-day work that I honestly often cry using it.<p>On how to get your work back, name your WIPs, or stash specific files, refer to the <a href=https://git-scm.com/book/en/v1/Git-Tools-Stashing>docs on Git staging</a>. No way I am better at explaining than the documentation itself!<h3 id=commit-selected-chunks-of-your-work>Commit selected chunks of your work</h3><p>Remember the “I work in a very messy way, iterating between features” excuse? This helps. (It helped me yesterday when I refactored and introduced something new to it – should not be done altogether! –  at the same time without noticing.)<p>Besides only adding a specific file to your commit with <code>git add</code>, you may want to add only a <strong>chunk of the file’s code</strong> to a commit. That can be achieved with the <code>--patch</code> flag:<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#282a36><code class=language-bash data-lang=bash><span style=color:#50fa7b>git</span><span> add</span><span style=color:#ffb86c;font-style:italic> --patch
</span></code></pre><p>That’s another interface you’ll have to get comfortable with. You can also try out its <code>--interactive</code> option.<h4 id=using-vs-code>Using VS Code?</h4><p>VS Code has a powerful built-in Git editor that allows you to add chunks of code to a commit. To stage specific lines to commit later, open VS Code’s Git editor, select the lines of code you feel should go into a commit, and “Stage selected changes” by right-clicking on it.<figure class=text-center><picture><img alt="Showing how to use 'Stage Selected Changes' in VS Code" src=../../media/2018/vs-code-stage-selected-changes.png></picture><figcaption>Changed the whole thing but want to commit only a chunk of it? VS Code has got you covered.</figcaption></figure><p>The <a href=https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette>Command Palette</a> also has a “Git: Stage selected changes” option.<h3 id=rename-commit-messages-for-meaning>Rename commit messages for meaning</h3><p>You had a look at the final history and found out your commit messages need some love. To change your latest commit (HEAD), you can just do <code>git commit --amend</code>; for other commits, you’ll have to rebase.<p>Let’s say you want to fix the latest 5 commits:<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#282a36><code class=language-bash data-lang=bash><span style=color:#50fa7b>git</span><span> rebase</span><span style=color:#ffb86c;font-style:italic> -i</span><span> @</span><span style=color:#bd93f9>~</span><span>5
</span></code></pre><p>That will open up the <strong>interactive rebase</strong> you’re already familiar with. Find the commit you want, change pick to <code>e</code> (edit), and save and close the file; after Git rewinds to that commit, edit its message with <code>git commit --amend</code>, and run <code>git rebase --continue</code> when you’re done.<h2 id=got-a-clear-history-push-it>Got a clear history? Push it!</h2><blockquote><p>Commit Often, Perfect Later, Publish Once.<sup class=footnote-reference><a href=#1>1</a></sup></blockquote><p>Make sure that your branch has got a clear, readable and meaningful history…<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#282a36><code class=language-bash data-lang=bash><span style=color:#50fa7b>git</span><span> log</span><span style=color:#ffb86c;font-style:italic> --oneline
</span></code></pre><p>Then push it into the remote repository!<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#282a36><code class=language-bash data-lang=bash><span style=color:#50fa7b>git</span><span> push origin head
</span></code></pre><p class=note>If you have already pushed (Y THO???!), you can (carefully) use the force option (<code>-f</code>) to rewrite the remote history.<h2 id=extra-fixing-the-first-history>Extra: Fixing the first history</h2><p>Remember the first history? We can fix it. It’s definitely harder to change it after it’s done, but totally doable with <code>rebase -i</code>. A possible solution would be:<pre class=language-sh data-lang=sh style=color:#f8f8f2;background-color:#282a36><code class=language-sh data-lang=sh><span style=color:#50fa7b>squash </span><span style=color:#ff79c6>[</span><span>290xx26</span><span style=color:#ff79c6>]</span><span> Resolve merge conflicts
</span><span style=color:#50fa7b>pick </span><span style=color:#ff79c6>[</span><span>9efxxf2</span><span style=color:#ff79c6>]</span><span> Refactor event listener for form fields
</span><span style=color:#50fa7b>squash </span><span style=color:#ff79c6>[</span><span>5d9xx5a</span><span style=color:#ff79c6>]</span><span> Update snapshots
</span><span style=color:#50fa7b>squash </span><span style=color:#ff79c6>[</span><span>948xxfa</span><span style=color:#ff79c6>]</span><span> Update dispatch event
</span><span style=color:#50fa7b>delete </span><span style=color:#ff79c6>[</span><span>f5xxea1</span><span style=color:#ff79c6>]</span><span> WIP
</span><span style=color:#50fa7b>delete </span><span style=color:#ff79c6>[</span><span>f8xxaae</span><span style=color:#ff79c6>]</span><span> Revert change
</span><span style=color:#50fa7b>delete </span><span style=color:#ff79c6>[</span><span>49xxf55e</span><span style=color:#ff79c6>]</span><span> Revert changes
</span><span style=color:#50fa7b>squash </span><span style=color:#ff79c6>[</span><span>02xxdf1</span><span style=color:#ff79c6>]</span><span> Update snapshots
</span><span style=color:#50fa7b>squash </span><span style=color:#ff79c6>[</span><span>21xx329</span><span style=color:#ff79c6>]</span><span> Pass down prop
</span><span style=color:#50fa7b>pick </span><span style=color:#ff79c6>[</span><span>28xxa865</span><span style=color:#ff79c6>]</span><span> Fix onChange event and add minimal design  in form
</span><span style=color:#50fa7b>squash </span><span style=color:#ff79c6>[</span><span>cfxx37c</span><span style=color:#ff79c6>]</span><span> U[date snapshots
</span><span style=color:#50fa7b>pick </span><span style=color:#ff79c6>[</span><span>cfxx36c</span><span style=color:#ff79c6>]</span><span> Update form to handle onChange event for autofill
</span><span style=color:#50fa7b>fixup </span><span style=color:#ff79c6>[</span><span>242xx25</span><span style=color:#ff79c6>]</span><span> Fix another bug with onChange
</span><span style=color:#50fa7b>squash </span><span style=color:#ff79c6>[</span><span>f7xx738</span><span style=color:#ff79c6>]</span><span> Update form component
</span><span style=color:#50fa7b>squash </span><span style=color:#ff79c6>[</span><span>09xx868</span><span style=color:#ff79c6>]</span><span> Update snapshots
</span></code></pre><p><strong>Be mindful about your decisions and make sure you are not losing work along the way</strong>. I deleted commits unused commits (WIP then reverted), squashed “fix” and “update tests” commits, and then picked only those that are meaningful batches of work.<p>I could have also split <code>Fix onChange event and add minimal design  in form</code> into two separate commits… But that’s for a future post.<h2 id=final-considerations>Final considerations</h2><p>Nowadays, I can say for sure that Git helps me to work better. Those techniques you’ve learned are all part of my daily workflow.<p>There is always something I don’t know about Git though, so I keep exploring. I recommend you do to do the same, and you can start right from your command line:<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#282a36><code class=language-bash data-lang=bash><span style=color:#50fa7b>git</span><span> help</span><span style=color:#ffb86c;font-style:italic> -w</span><span> reset
</span></code></pre><p>Finally, if somehow you don’t feel comfortable with moving around your work from the command line, I’d recommend Git GUI clients<sup class=footnote-reference><a href=#2>2</a></sup> – they are powerful and simplify visualising branches and its commits, especially when it gets tough<sup class=footnote-reference><a href=#3>3</a></sup>.<p>I hope you have better, more sane, work days after that!<div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p><a href=http://sethrobertson.github.io/GitBestPractices/>Commit Often, Perfect Later, Publish Once: Git Best Practices</a> by Seth Robertson.</div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p>Some clients I can think of: <a href=https://desktop.github.com/>GitHub’s Git client</a> (free), <a href=https://www.gitkraken.com/>Git Kraken</a> (free), <a href=https://www.git-tower.com/>Git Tower</a> (paid).</div><div class=footnote-definition id=3><sup class=footnote-definition-label>3</sup><p>It will get tough, because source code management is not easy. Anyhow, it’s always tougher when you care about things anyway. Easiest thing is not to care about anything at all.</div></div></article></div></body><script src=/footnotes.js></script>