<!doctype html><html class="scroll-smooth md:border-[10px] md:border-solid min-h-screen md:border-purple" lang=en><head><meta charset=utf-8><link href="/css/style.css?h=012c5f95ea1463230821" rel=stylesheet><meta content="width=device-width,initial-scale=1" name=viewport><title>Desmitificando Seletores Complexos | Diéssica Gurskas</title><body class="text-gray-700 font-body antialiased"><div class="bg-blog px-3 md:px-10 min-h-[calc(100vh-16px)] lg:min-h-[calc(100vh-20px)]"><div class="py-12 mb-4 text-center space-x-8 text-md md:text-lg relative z-20"><a class="no-underline font-extrabold hover:border-green hover:border-b-2" href=/>diessi.ca</a><a class="no-underline hover:border-green hover:border-b-2 border-green border-b-2" href=/blog/>Blog</a><a class="no-underline hover:border-green hover:border-b-2" href=/misc/>Misc</a></div><article class="container mx-auto w-full xl:w-1/2 pb-8"><header class="xl:-mx-56 text-center mb-8 md:mb-12"><div class="uppercase tracking-widest opacity-60 mb-4 text-xs">November 28, 2013</div><h1 class="font-extrabold font-display text-3xl md:text-5xl xl:text-6xl text-slate-900">Desmitificando Seletores Complexos</h1></header><div class="prose prose-sm md:prose 2xl:prose-lg prose-hr:text-red prose-hr:w-48 prose-hr:h-0.5 prose-hr:mx-auto prose-hr:my-4 prose-hr:bg-black prose-hr:opacity-20 prose-hr:border-0 prose-hr:rounded prose-hr:md:my-10 prose-pre:rounded-none prose-blockquote:border-0 prose-blockquote:text-center prose-blockquote:text-xl prose-blockquote:text-current tracking-tight mx-auto prose-headings:text-slate-800 prose-headings:w-max prose-headings:font-display prose-headings:font-extrabold"><p>Se existem recursos no CSS que a total compreensão se restringe a uma parcela de desenvolvedores, esses são os combinadores filhos (>), irmãos adjacentes (+) e adjacentes gerais (~).<p>Sem dúvidas, esses 3 combinadores são tão poderosíssimos quanto mal-explicados. É importante compreendê-los integralmente e há dois bons motivos para isso: o seletor descendente não dá conta de tudo e, o óbvio: o CSS está evoluindo.<h2 id=x-y>X > Y</h2><blockquote><p>Todo filho é necessariamente descendente, mas nem todo descendente é necessariamente filho.<footer>— <cite>Eu, sobre família</cite></footer></blockquote><p>Para que Y seja alvo da seleção, não importa a posição; basta que seja descendente direto de X - isso é, filho. Em outras palavras, basta que esteja interno diretamente ao elemento pai - e seja somente descendente dele. Isso quer dizer que Y não será alvo caso esteja interno a um elemento Z, mesmo que este esteja interno a X. Por essa razão o combinador “>” é também chamado de <strong>direto</strong>, pois não admite elementos internos indiretamente.<h3 id=seletor-descendente-vs-seletor-filho>Seletor descendente vs. seletor filho</h3><p>Lembrando da frase dita no início desse tópico, você já entende a diferença. Enquanto o <strong>descendente</strong> (X Y) herda as propriedades aos elementos direta e indiretamente internos (filhos, netos, bisnetos…), o alvo do <strong>combinador filho</strong> são os filhos unicamente diretos - sim, falar isso é redundante. O que faz todo sentido, afinal, um filho é tanto filho quanto descendente; e o neto, bisneto, trineto não é um filho, mas é descendente.<h4 id=na-pratica>Na prática</h4><p>Imaginemos um artigo e seus respectivos parágrafos. Dentro desse artigo, haverá uma seção de informações que não estará diretamente relacionada ao artigo. Como o que se quer destacar é a leitura do artigo, seus parágrafos terão mais ênfase de alguma forma.<h5 id=html>HTML</h5><pre class=language-html data-lang=html style=color:#f8f8f2;background-color:#282a36><code class=language-html data-lang=html><span><</span><span style=color:#ff79c6>article</span><span>>
</span><span>  <</span><span style=color:#ff79c6>h1</span><span>>Título do artigo&LT/</span><span style=color:#ff79c6>h1</span><span>>
</span><span>  <</span><span style=color:#ff79c6>p</span><span>>Primeiro parágrafo&LT/</span><span style=color:#ff79c6>p</span><span>>
</span><span>  <</span><span style=color:#ff79c6>p</span><span>>Segundo parágrafo&LT/</span><span style=color:#ff79c6>p</span><span>>
</span><span>  <</span><span style=color:#ff79c6>aside</span><span>>
</span><span>    <</span><span style=color:#ff79c6>h2</span><span>>Informações&LT/</span><span style=color:#ff79c6>h2</span><span>>
</span><span>    <</span><span style=color:#ff79c6>p</span><span>>Lorem ipsum dolor sit amet, consectetur adipisicing elit.&LT/</span><span style=color:#ff79c6>p</span><span>>
</span><span>  &LT/</span><span style=color:#ff79c6>aside</span><span>>
</span><span>  <</span><span style=color:#ff79c6>p</span><span>>Terceiro parágrafo&LT/</span><span style=color:#ff79c6>p</span><span>>
</span><span>&LT/</span><span style=color:#ff79c6>article</span><span>>
</span></code></pre><h5 id=css>CSS</h5><pre class=language-css data-lang=css style=color:#f8f8f2;background-color:#282a36><code class=language-css data-lang=css><span style=color:#ff79c6>article </span><span>> </span><span style=color:#ff79c6>p </span><span>{
</span><span>  </span><span style=color:#66d9ef;font-style:italic>font-style</span><span>: </span><span style=color:#6be5fd>italic</span><span>;
</span><span>}
</span></code></pre><p>Assim, somente os parágrafos que são filhos diretos do elemento <strong>article</strong> serão estilizados.<h2 id=x-y-1>X + Y</h2><p>Se para ser alvo do seletor filho a posição era irrelevante, para ser alvo de um <strong>seletor irmão adjacente</strong> sua posição é critério decisivo. O elemento Y deve ser o primeiro elemento após X, com ambos dentro de um mesmo elemento Z (pai). O nome, portanto, é bem autoexplicativo: são <strong>irmãos</strong> por possuírem o mesmo pai (no caso, Z) e <strong>adjacentes</strong> por estarem necessariamente próximos.<h4 id=na-pratica-1>Na prática 1</h4><p>Supondo um artigo constituído por um título e 3 parágrafos. O primeiro parágrafo após o título servirá como uma introdução ao artigo e, portanto, deve ser destacado com um aumento no tamanho da fonte.<h5 id=html-1>HTML</h5><pre class=language-html data-lang=html style=color:#f8f8f2;background-color:#282a36><code class=language-html data-lang=html><span><</span><span style=color:#ff79c6>article</span><span>>
</span><span>  </span><span style=color:#6272a4>&LT!-- Z -->
</span><span>  <</span><span style=color:#ff79c6>h1</span><span>>Título do artigo&LT/</span><span style=color:#ff79c6>h1</span><span>>
</span><span>  </span><span style=color:#6272a4>&LT!-- X -->
</span><span>  <</span><span style=color:#ff79c6>p</span><span>>Lorem ipsum dolor sit amet, consectetur adipisicing elit.&LT/</span><span style=color:#ff79c6>p</span><span>>
</span><span>  </span><span style=color:#6272a4>&LT!-- Y -->
</span><span>  <</span><span style=color:#ff79c6>p</span><span>>Debitis sint aperiam numquam nisi animi porro in reprehenderit!&LT/</span><span style=color:#ff79c6>p</span><span>>
</span><span>  <</span><span style=color:#ff79c6>p</span><span>>Magnam atque placeat fuga sed eligendi maxime neque labore. Doloribus?&LT/</span><span style=color:#ff79c6>p</span><span>>
</span><span>&LT/</span><span style=color:#ff79c6>article</span><span>>
</span></code></pre><h5 id=css-1>CSS</h5><pre class=language-css data-lang=css style=color:#f8f8f2;background-color:#282a36><code class=language-css data-lang=css><span style=color:#ff79c6>h1 </span><span>+ </span><span style=color:#ff79c6>p </span><span>{
</span><span>  </span><span style=color:#66d9ef;font-style:italic>font-size</span><span>: </span><span style=color:#bd93f9>20</span><span style=color:#ff79c6>px</span><span>;
</span><span>}
</span></code></pre><h4 id=na-pratica-2>Na prática 2</h4><p>O <strong>checkbox hack</strong> funciona com o uso do combinador irmão adjacente.<h4 id=html-2>HTML</h4><pre class=language-html data-lang=html style=color:#f8f8f2;background-color:#282a36><code class=language-html data-lang=html><span><</span><span style=color:#ff79c6>input </span><span style=color:#50fa7b>type</span><span>=</span><span style=color:#f1fa8c>"checkbox" </span><span style=color:#50fa7b>id</span><span>=</span><span style=color:#f1fa8c>"hider" </span><span>/>
</span><span><</span><span style=color:#ff79c6>div</span><span>>Hide me if you can!&LT/</span><span style=color:#ff79c6>div</span><span>>
</span><span><</span><span style=color:#ff79c6>label </span><span style=color:#50fa7b>for</span><span>=</span><span style=color:#f1fa8c>"hider"</span><span>>Esconder div&LT/</span><span style=color:#ff79c6>label</span><span>>
</span></code></pre><h4 id=css-2>CSS</h4><pre class=language-css data-lang=css style=color:#f8f8f2;background-color:#282a36><code class=language-css data-lang=css><span style=color:#ff79c6>input</span><span>[</span><span style=color:#50fa7b>type</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>"checkbox"</span><span>] {
</span><span>  </span><span style=color:#66d9ef;font-style:italic>display</span><span>: </span><span style=color:#6be5fd>none</span><span>; </span><span style=color:#6272a4>/* Esconde o checkbox */
</span><span>}
</span><span style=color:#ff79c6>input</span><span>:checked + </span><span style=color:#ff79c6>div </span><span>{
</span><span>  </span><span style=color:#66d9ef;font-style:italic>display</span><span>: </span><span style=color:#6be5fd>none</span><span>; </span><span style=color:#6272a4>/* Quando o checkbox for checado, a div será escondida */
</span><span>}
</span></code></pre><h2 id=x-y-2>X ~ Y</h2><p>Seletor do <strong>CSS 3</strong>, o combinador <strong>adjacente geral</strong> tem uma definição bem semelhante ao irmão adjacente. Para que Y seja alvo, os elementos X e Y devem ser filhos de um mesmo elemento (irmãos) e X deve preceder Y, direta ou indiretamente - isso é, para que Y seja alvo, esse precedimento não precisa ser imediato.<h4 id=na-pratica-3>Na prática</h4><p>Esse combinador contorna algumas inflexibilidades do <strong>combinador irmão adjacente</strong>. Ainda com o exemplo do <strong>checkbox hack</strong>, podemos personalizar o elemento de forma não tão específica quanto à sua posição:<h4 id=html-3>HTML</h4><pre class=language-html data-lang=html style=color:#f8f8f2;background-color:#282a36><code class=language-html data-lang=html><span><</span><span style=color:#ff79c6>input </span><span style=color:#50fa7b>type</span><span>=</span><span style=color:#f1fa8c>"checkbox" </span><span style=color:#50fa7b>id</span><span>=</span><span style=color:#f1fa8c>"shower" </span><span>/>
</span><span><</span><span style=color:#ff79c6>label </span><span style=color:#50fa7b>for</span><span>=</span><span style=color:#f1fa8c>"shower"</span><span>>Mostrar div&LT/</span><span style=color:#ff79c6>label</span><span>>
</span><span><</span><span style=color:#ff79c6>div</span><span>>Hide me if you can!&LT/</span><span style=color:#ff79c6>div</span><span>>
</span><span><</span><span style=color:#ff79c6>div</span><span>>Hide me too if you can!&LT/</span><span style=color:#ff79c6>div</span><span>>
</span></code></pre><h4 id=css-3>CSS</h4><pre class=language-css data-lang=css style=color:#f8f8f2;background-color:#282a36><code class=language-css data-lang=css><span style=color:#ff79c6>input</span><span>[</span><span style=color:#50fa7b>type</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>"checkbox"</span><span>],
</span><span style=color:#ff79c6>div </span><span>{
</span><span>  </span><span style=color:#66d9ef;font-style:italic>display</span><span>: </span><span style=color:#6be5fd>none</span><span>; </span><span style=color:#6272a4>/* Esconde o checkbox e a div, por padrão */
</span><span>}
</span><span style=color:#ff79c6>input</span><span>:checked ~ </span><span style=color:#ff79c6>div </span><span>{
</span><span>  </span><span style=color:#66d9ef;font-style:italic>display</span><span>: </span><span style=color:#6be5fd>block</span><span>; </span><span style=color:#6272a4>/* Quando o checkbox for checado, a div aparecerá */
</span><span>}
</span></code></pre><h2 id=conclusao>Conclusão</h2><p>As linguagens CSS e HTML foram documentadas para serem intuitivas: os elementos formam famílias com outros elementos pais, filhos, descendentes, irmãos…. Isso fica claro no nome dos seletores, que têm papel importante na compreensão do combinador; afinal, caso o desenvolvedor entenda que irmãos tem o mesmo pai e que filhos são descendentes diretos do pai, ele poderá tirar um bom proveito do nome dos combinadores para compreender seus funcionamentos.<blockquote><p>[…] In both cases, non-element nodes (e.g. text between elements) are ignored when considering adjacency of elements.<footer><cite><span>W3C</span>, sobre <a href=http://www.w3.org/TR/css3-selectors/>Selectors Level 3</a></cite></footer></blockquote><p>Há uma grande confusão - e com razão - entre os seletores irmãos adjacentes e irmãos gerais. Essa confusão se origina não só de suas classificações como <a href=http://www.w3.org/TR/css3-selectors/#sibling-combinators>seletores de combinação</a>, mas em seus comportamento e definição semelhantes. Tanto é verdade que o combinador adjacente geral (~) se comportará muitas vezes como um irmão adjacente (+), com a diferença de que o adjacente geral é menos exigente quanto à posição do elemento-alvo.<p>O uso será, portanto, facultativo em diversas situações. E, nesse caso, a minha recomendação é dar prioridade ao combinador adjacente, visto que é um seletor do CSS 2.1 e, portanto, compatível com uma maior gama de browsers. :-)<h2 id=referencias>Referências</h2><ul><li><strong>W3C</strong>. <a href=http://www.w3.org/TR/CSS21/selector.html>Selectors</a><li><strong>W3C</strong>. <a href=http://www.w3.org/TR/css3-selectors/>Selectors Level 3</a>, 29 setembro de 2011</ul></div></article></div></body><script src=/footnotes.js></script>